# kunit

`kunit` is a `no_std` test harness for Rust kernel crates (currently `x86_64` and `aarch64`).
It runs tests inside QEMU, emits structured JSONL test events through the debug console, and integrates with CI via the reusable workflow in `.github/workflows/kernel-tests.yml`.

## Architecture

- `src/lib.rs` wires the crate-level test framework (`custom_test_frameworks`) and re-exports:
  - `#[kunit]` attribute macro from `kunit_macros`
  - `klib!` macro and `KlibConfig` helpers
  - test runner entrypoints
- `src/test/runner.rs` is the core orchestrator:
  - tracks the static test list generated by `#[kunit]`
  - prints per-module progress to serial output
  - records pass/fail/ignore JSON events
  - exits QEMU when complete
- `src/test/output.rs` defines the JSONL contract written to debugcon:
  - first row: `{ "test_group": "...", "test_count": N }`
  - one row per test: `{ "test": "...", "result": "pass|fail|ignore", ... }`
- `src/arch/*` provides architecture-specific primitives:
  - cycle counter reads
  - debug console writes
  - QEMU/system exit hooks
- `src/macros/klib.rs` provides `klib!`, which sets up test boot plumbing for kernel-style libraries:
  - start symbol
  - panic handler delegation
  - optional before/after test hooks

## Runtime Flow

1. Kernel crate invokes `cargo test --target linker/<arch>-grovean.json`.
2. `klib!` initializes the harness (`kunit::init_harness("<group>")`) and calls `test_main()`.
3. `#[kunit]` functions are collected as `Test` entries and executed by `KernelTestRunner`.
4. Runner writes JSON lines to debugcon (group header + per-test outcomes).
5. The host runner (`k1`) captures debugcon output and materializes files under `.k1/testing/testing-<crate>.jsonl`.
6. CI validates those files and fails the job if tests fail or output is malformed/incomplete.

Example JSONL file (`.k1/testing/testing-extended-crate.jsonl`):

```json
{ "test_group": "extended-crate", "test_count": 1 }
{ "test": "extended_crate::tests::trivial_basic_crate_assertion", "result": "pass", "cycle_count": 3646}
```

## Kernel Crate Integration

For a kernel crate, add `kunit` as a **dev-dependency**.

```toml
[dev-dependencies]
kunit = "0.1.0"
```

Then ensure the crate defines `klib!` in the crate root (typically `src/lib.rs`) so test boot/panic wiring is present.

```rust
#![no_std]

#[cfg(test)]
kunit::klib!("kernel");

#[cfg(test)]
mod tests {
    use kunit::kunit;

    #[kunit]
    fn trivial_assertion() {
        assert_eq!(1 + 1, 2);
    }
}
```

Notes:
- `klib!("kernel")` sets the test group used in JSON output and output filenames.
- If needed, use `KlibConfigBuilder` to run setup/teardown hooks around `test_main()`.
- `klib!` emits Limine request markers; your kernel crate should already include `limine` where applicable.

## CI Integration (Reusable Workflow)

This repo exposes `.github/workflows/kernel-tests.yml` as a public reusable workflow (`workflow_call`).

Kernel repositories can call it like:

```yaml
name: Kernel Tests

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  test:
    uses: <owner>/kunit/.github/workflows/kernel-tests.yml@main
    with:
      rust-toolchain: nightly
      targets: |
        linker/x86_64-grovean.json
        linker/aarch64-grovean.json
      kboot-features: ci
      cargo-test-args: --verbose
```

The workflow:
- installs Rust and required system packages
- installs `k1` via `cargo install k1`
- adds `rust-src` (`nightly-x86_64-unknown-linux-gnu`)
- runs `cargo test` per target
- validates `.k1/testing/testing-*.jsonl` for format and pass/fail correctness
- uploads JSONL artifacts

Because validation and test execution are part of job success criteria, this acts as a GitHub status gate on pushes/PRs in caller kernel repos.
